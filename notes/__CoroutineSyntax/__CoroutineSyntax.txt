The following are valid command macros used to define coroutines. Please remember that
the code that goes in between each coroutine command macro is in separate GML functions.
These functions are executed in the same scope (the coroutine root struct) but otherwise
they cannot share local variables ("var" variables) due to being in separate functions.


CO_BEGIN:
    Starts a coroutine definition. It must always be matched by a CO_END command.
    CO_BEGIN returns a "coroutine root" struct. You should keep a reference to this
    struct to access the coroutine at a later point in your code.


CO_END:
    Ends the definition of a coroutine. It must be called to finish defining the coroutine.


THEN:
    Acts as a way to separate different coroutine operations. THEN is required syntax in a
    handful of situations, but it is also useful to break up long sections of code that are
    expensive to execute and are causing the coroutine to take longer per frame to execute
    than expected.


YIELD:
    Instructs the coroutine to immediately cease execution of the coroutine and return a
    value. Unlike PAUSE or RETURN, execution will resume in the next frame without any
    other action required. The value returned can be read from the coroutine using the
    .Get() method.
    
    YIELD syntax must look like this:
    
        YIELD <expression> THEN
        //Further operations


PAUSE:
    Instructs the coroutine to immediately pause execution and return a value. Unlike RETURN,
    the execution of the coroutine may be resumed using the .Resume() method. The value
    returned can be read from the coroutine using the .Get() method.
    
    PAUSE syntax must look like this:
    
        PAUSE <expression> THEN
        //Further operations


RETURN:
    Instructs the coroutine to immediately stop execution and return a value. Unlike PAUSE,
    the coroutine's execution is stopped entirely (though the coroutine may be restarted with
    the .Restart() method). This "full stop" behaviour also applies to coroutines set to
    execute continuously (see .SetContinuous()) wherein a continuously executing coroutine
    will not restart if a RETURN command is encountered.
    
    The value returned by this command can be read from the coroutine using the .Get() method.
    
    RETURN syntax must look like this:
    
        RETURN <expression> THEN
        //Further operations


REPEAT:
    Analogous to GameMaker's own repeat() loop. It is not necessary to use this macro in all
    cases to replace standard repeat() loops. There are two cases where using REPEAT...POP
    is advised:
    
    1) When the repeat() loop would otherwise contain a YIELD or RETURN command
    2) When the repeat() loop contains expensive, time-consuming code
    
    REPEAT syntax must look like this:
    
        REPEAT <expression> THEN
            //Further operations
        POP


WHILE:
    Analogous to GameMaker's own while() loop. It is not necessary to use this macro in all
    cases to replace standard while() loops. There are two cases where using WHILE...POP
    is advised:
    
    1) When the while() loop would otherwise contain a YIELD or RETURN command
    2) When the while() loop contains expensive, time-consuming code
    
    WHILE syntax must look like this:
    
        WHILE <condition> THEN
            //Further operations
        POP


FOREACH:
    Convience feature that iterates over either 1) an array 2) a struct 3) the YIELD output
    from a coroutine. Care should be taken not to modify an array or struct because the total
    number of iterations is calculated when the FOREACH loop begins. When iterating over the
    output from a coroutine, the YIELD value is assigned to the iterator variable.
    
    FOREACH syntax must look like this:
    
        FOREACH <iteratorVariable> IN <expression> THEN
            //Further operations
        POP


POP:
    Necessary to terminate a REPEAT or WHILE or FOREACH loop. It must not be used in other contexts.


BREAK:
    Analogous to GameMaker's own break command. Escapes either a REPEAT loop or a WHILE loop
    immediately without executing the rest of the code in the loop. The remainder of the
    code in the coroutine will execute as normal.


IF / ELSE / ELSE_IF / END_IF:
    Analogous to GameMaker's own if/else commands. An IF must be matched by an END_IF. It is
    typically not required to use these particular macros. You should use these macros if
    the if-branch (or else-branch etc.) contains a YIELD or RETURN command.


AWAIT:
    Waits for its condition to return <true> then continues with execution.
    AWAIT syntax must look like this:
    
        AWAIT <condition> THEN
        //Further operations


DELAY:
    Waits for a given amount of real time to pass. DELAY durations are measured in milliseconds.
    DELAY syntax must look like this:
    
        DELAY <expression> THEN
        //Further operations


AWAIT_ASYNC_HTTP:
AWAIT_ASYNC_SOCIAL:
AWAIT_ASYNC_SAVE_LOAD:
AWAIT_ASYNC_DIALOG:
AWAIT_ASYNC_SYSTEM:
AWAIT_ASYNC_STEAM:
    Waits for the relevant async event to be triggered. A block of code is executed
    every time that async event is triggered, regardless of whether that async event
    is relevant for the coroutine. This is unfortunate, but it's also the way GameMaker
    is designed.
    
    The code that follows the AWAIT_ASYNC_* command cannot contain any coroutine macros
    (with the exception of ASYNC_COMPLETE). This is because async_load will often
    contain data that is volatile, data that will not persistent beyond the end of the
    async event. If you'd like to perform expensive operations on data that's returned
    by an async event, you should make a copy of it and then process that data outside
    of the AWAIT_ASYNC_* block.
    
    AWAIT_ASYNC_* code may be executed when an operation has timed out. By default,
    no timeout duration is set and operations may hang forever. You can customize
    the timeout duration using the TIMEOUT macro (see below). When an async operation
    times out, async_load is a negative number. You should always write code to check
    if an async operation has timed out i.e. you should always handle the cases where
    async_load is negative.
    
    AWAIT_ASYNC_* syntax must look like this:
    
        AWAIT_ASYNC_*
            if (async_load < 0) <code to execute when an async event times out>
            <code to execute when receiving an async event>
            if (<condition>) ASYNC_COMPLETE;
        THEN
        //Further operations


ASYNC_COMPLETE:
    Indicates that the async operation has completed and the coroutine should continue
    execution of code. If you do not execute this command inside your async code block
    then the async operation may hang indefinitely.


TIMEOUT:
    Adds a timeout behaviour to an AWAIT_ASYNC_* command. By default, AWAIT_ASYNC_* commands
    have no timeout duration and it is possible for operations to hang forever. The TIMEOUT
    command macro is used to set a timeout duration to handle failed operations. The timeout
    duration is measured in milliseconds.
    
    When async code is executed but the operation has timed out, async_load will be
    set to a negative number. You should always write code to handle cases where async_load
    is a negative number to avoid unexpected problems.
    
    TIMEOUT syntax must look like this:
    
        AWAIT_ASYNC_*
            if (async_load < 0) <code to execute when an async event times out>
            <code to execute when receiving an async event>
            if (<condition>) ASYNC_COMPLETE;
        TIMEOUT <expression> THEN
        //Further operations