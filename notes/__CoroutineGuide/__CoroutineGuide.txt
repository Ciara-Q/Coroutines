Coroutines are a way to execute code over the course of many frames/steps without holding
up execution of other code in your game. This is often useful for cutscenes, AI, or UI
animations.

GameMaker has no native support for coroutines. This one-script library adds support,
albeit somewhat restricted by what's possible by bending and twisting GML. This library
is, in principle, supported across all platforms though upsteam bugs may be present,
especially on HTML5 and Opera GX targets.

This library was written by Juju Adams in 2021, and is MIT licensed. For a copy of the
license, please scroll down to the System region.



This implementation of coroutines has a particular syntax that needs to be followed.
This syntax is built from macros, allowing for reasonably natural expressions to be
written whilst the actual GML clutter is hidden from view.

Coroutines act as sort of "sandboxes" where code can be run semi-separately from the rest
of your game. Coroutine code is run in the scope of a "coroutine root" created for each
coroutine. Coroutine roots are structs and can store variables as you normally would.
Coroutines can freely interact with code outside of the coroutine, though care should be
taken to avoid writing code that is unstable if it is executed in a different order than
expected (this is easy to do with asynchronous execution such as a coroutine).

Before writing any coroutines, you should check that CoroutineEventHook() is being
called exactly once every frame in a Step event, typically in a persistent instance. This
function must be called otherwise coroutines will not be executed. Additionally, if you
would like to use the AWAIT_ASYNC_* feature you will need to place CoroutineEventHook()
in every async event that you plan to use. Take care that you do not accidentally
deactivate this persistent instance as that will also prevent coroutines from functioning
appropriately.

For convenience, oCoroutineManager is included in the Coroutines folder in your asset
browser. You can add an instance of this object to your first room and it will take care
of calls to CoroutineEventHook() for you. You will need to ensure this instance is never
destroyed or deactivated, of course!



    example = COROUTINE_BEGIN
        oPlayer.x += 4;
        oEnemy.x += 2;
    COROUTINE_END

Above is a very simple example of a basic (and kind of useless) coroutine. The
COROUTINE_BEGIN macro starts the creation of the coroutine. After that we have two lines
of standard GML that moves oPlayer and oEnemy rightwards different amounts. Finally,
the COROUTINE_END macro closes the coroutine definition.

Note that the COROUTINE_BEGIN macro returns a value that is stored in the "example"
variable. COROUTINE_BEGIN returns the "coroutine root" struct mentioned above. You
should keep a reference to the coroutine root so that you can interact with the
coroutine at a later point in your code. Coroutines will execute automatically.

Let's try something a bit more useful:

    example = COROUTINE_BEGIN
        WHILE (oPlayer.x < 500) THEN
            oPlayer.x += 4;
            oEnemy.x += 4;
        POP
    COROUTINE_END

Here we've used a WHILE macro to create a while-loop inside our coroutine. You can use
standard GML while-loops inside a coroutine, there's nothing stopping you, but
coroutines cannot YIELD or PAUSE within a standard GML while-loop. Additionally, the
RETURN and BREAK macros cannot be used inside a GML while-loop.

Similar rules apply to repeat() loop and if-branches (and else-branches etc.). A
coroutine cannot YIELD, PAUSE, RETURN, or BREAK inside a standard GML repeat() loop
or if-branch; instead, you should use the REPEAT / IF / ELSE / ELSE_IF macros. See the
__CoroutineSyntax Notes document for more information.

The use of the POP macro at the end of the while-loop is essential. Every WHILE and
REPEAT command must be matched by a POP command, much like you'd match an open bracket
and a close bracket. The code defined between WHILE/REPEAT and POP is the looped code.

Other flow control macros (AWAIT, DELAY etc.) do not need POP and instead require a
THEN macro:

    example = COROUTINE
        AWAIT (mouse_x > room_width/2) THEN
        YIELD "mouse on the right" THEN
        DELAY 1000 THEN
        AWAIT (mouse_x < room_width/2) THEN
        YIELD "mouse on the left" THEN
    END



Code that is written between coroutine command macros is, in reality, stored in separate
GML functions. This means local variable will not persistent between different code blocks
in coroutine syntax. This is unfortunate but, owing to coroutines being executed in their
own scope, this ends up being of little trouble. Let's take a look at a simple repeat loop
in GML:
    
    var _i = 0;
    repeat(array_length(array))
    {
        if (array[_i] == target) break;
        _i++;
    }
    show_debug_message("Found at index=" + string(_i));

In coroutine syntax, we could write this as:

    COROUTINE_BEGIN
        _i = 0;
        REPEAT array_length(array) THEN
            if (array[_i] == target) BREAK;
            _i++;
        POP;
        show_debug_message("Found at index=" + string(_i));
    COROUTINE_END

Let's look at the actual GML that this generates (though we're skipping some of the
apparatus that wraps around the following calls):

    __CoroutineFunction(function()
    {
        _i = 0;
    });
    __CoroutineRepeat(function()
    {
        return array_length(array);
    });
    __CoroutineFunction(function()
    {
        if (array[_i] == target)
        {
            global.__coroutineBreak = true;
            return undefined;
        }
        
        _i++;
    });
    __CoroutinePop();
    __CoroutineFunction(function()
    {
        show_debug_message("Found at index=" + string(_i));
    });

See how the initialization of "_i" is in a separate function to the body of the
repeat loop? This distance between the two pieces of code that reference _i means
that the variable cannot be defined as a traditional local "var" variable or we'd
run into syntax errors.eates a coroutine that handles the
animation on behalf of the instance.



COROUTINE_PARAMS can be used to set values in a coroutine that you're about to
create. This is useful for passing parameters into a coroutine, to set an initial
starting condition to process.

    function AnimateX(_instance, _target, _speed)
    {
        COROUTINE_PARAMS.instance = _instance;
        COROUTINE_PARAMS.target   = _target;
        COROUTINE_PARAMS.speed    = _speed;
        
        return COROUTINE_BEGIN
            WHILE (instance.x != target) THEN
                instance.x += min(target - instance.x, speed);
            POP
            // Done!
        COROUTINE_END
    }

The above function will animate the x-coordinate of the given instance over the
course of a number of frames. The function returns a coroutine root struct which
can have its .GetComplete() method called to detect when the animation has finished.